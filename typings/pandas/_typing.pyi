"""
This type stub file was generated by pyright.
"""

import datetime
import sys
import numpy as np
import pandas as pd
from collections.abc import Callable, Hashable, Iterator, KeysView, Mapping, MutableSequence, Sequence
from datetime import tzinfo
from os import PathLike
from re import Pattern
from typing import Any, Literal, Protocol, SupportsIndex, TypedDict, Union, overload
from numpy import typing as npt
from pandas.core.arrays import ExtensionArray
from pandas.core.frame import DataFrame
from pandas.core.generic import NDFrame
from pandas.core.groupby.grouper import Grouper
from pandas.core.indexes.base import Index
from pandas.core.series import Series
from pandas.core.tools.datetimes import FulldatetimeDict
from typing_extensions import ParamSpec, TypeAlias, TypeVar
from pandas._libs.interval import Interval
from pandas._libs.missing import NAType
from pandas._libs.tslibs import BaseOffset, Period, Timedelta, Timestamp
from pandas.core.dtypes.dtypes import CategoricalDtype, ExtensionDtype
from pandas.io.formats.format import EngFormatter

P = ParamSpec("P")
HashableT = TypeVar("HashableT", bound=Hashable)
HashableT1 = TypeVar("HashableT1", bound=Hashable)
HashableT2 = TypeVar("HashableT2", bound=Hashable)
HashableT3 = TypeVar("HashableT3", bound=Hashable)
HashableT4 = TypeVar("HashableT4", bound=Hashable)
HashableT5 = TypeVar("HashableT5", bound=Hashable)
ArrayLike: TypeAlias = ExtensionArray | np.ndarray
AnyArrayLike: TypeAlias = ArrayLike | Index | Series
_T_co = TypeVar("_T_co", covariant=True)
class SequenceNotStr(Protocol[_T_co]):
    @overload
    def __getitem__(self, index: SupportsIndex, /) -> _T_co:
        ...
    
    @overload
    def __getitem__(self, index: slice, /) -> Sequence[_T_co]:
        ...
    
    def __contains__(self, value: object, /) -> bool:
        ...
    
    def __len__(self) -> int:
        ...
    
    def __iter__(self) -> Iterator[_T_co]:
        ...
    
    def index(self, value: Any, start: int = ..., stop: int = ..., /) -> int:
        ...
    
    def count(self, value: Any, /) -> int:
        ...
    
    def __reversed__(self) -> Iterator[_T_co]:
        ...
    


ListLike: TypeAlias = AnyArrayLike | SequenceNotStr[Any] | range
PythonScalar: TypeAlias = str | bool | complex
DatetimeLikeScalar: TypeAlias = Period | Timestamp | Timedelta
PandasScalar: TypeAlias = Period | Timestamp | Timedelta | Interval
_IndexIterScalar: TypeAlias = (str | bytes | datetime.date | datetime.datetime | datetime.timedelta | np.datetime64 | np.timedelta64 | bool | int | float | Timestamp | Timedelta)
Scalar: TypeAlias = (_IndexIterScalar | complex | np.integer | np.floating | np.complexfloating)
IntStrT = TypeVar("IntStrT", int, str)
TimestampConvertibleTypes: TypeAlias = (Timestamp | datetime.datetime | datetime.date | np.datetime64 | np.integer | float | str)
TimestampNonexistent: TypeAlias = (Literal["shift_forward", "shift_backward", "NaT", "raise"] | Timedelta | datetime.timedelta)
TimedeltaConvertibleTypes: TypeAlias = (Timedelta | datetime.timedelta | np.timedelta64 | np.integer | float | str)
Timezone: TypeAlias = str | tzinfo
ToTimestampHow: TypeAlias = Literal["s", "e", "start", "end"]
NDFrameT = TypeVar("NDFrameT", bound=NDFrame)
IndexT = TypeVar("IndexT", bound=Index)
AxisInt: TypeAlias = int
AxisIndex: TypeAlias = Literal["index", 0]
AxisColumn: TypeAlias = Literal["columns", 1]
Axis: TypeAlias = AxisIndex | AxisColumn
IndexLabel: TypeAlias = Hashable | Sequence[Hashable]
Level: TypeAlias = Hashable
Shape: TypeAlias = tuple[int, ...]
Suffixes: TypeAlias = tuple[str | None, str | None] | list[str | None]
Ordered: TypeAlias = bool | None
JSONSerializable: TypeAlias = PythonScalar | list | dict
Frequency: TypeAlias = str | BaseOffset
Axes: TypeAlias = ListLike
RandomState: TypeAlias = (int | ArrayLike | np.random.Generator | np.random.BitGenerator | np.random.RandomState)
NpDtype: TypeAlias = str | np.dtype[np.generic] | type[str | complex | bool | object]
Dtype: TypeAlias = ExtensionDtype | NpDtype
BooleanDtypeArg: TypeAlias = (type[bool] | Literal["bool"] | pd.BooleanDtype | Literal["boolean"] | type[np.bool_] | Literal["?", "b1", "bool_"] | Literal["bool[pyarrow]", "boolean[pyarrow]"])
IntDtypeArg: TypeAlias = (type[int] | Literal["int"] | pd.Int8Dtype | pd.Int16Dtype | pd.Int32Dtype | pd.Int64Dtype | Literal["Int8", "Int16", "Int32", "Int64"] | type[np.byte] | Literal["b", "i1", "int8", "byte"] | type[np.short] | Literal["h", "i2", "int16", "short"] | type[np.intc] | Literal["i", "i4", "int32", "intc"] | type[np.int_] | Literal["l", "i8", "int64", "int_", "long"] | type[np.longlong] | Literal["q", "longlong"] | type[np.intp] | Literal["p", "intp"] | Literal["int8[pyarrow]", "int16[pyarrow]", "int32[pyarrow]", "int64[pyarrow]"])
UIntDtypeArg: TypeAlias = (pd.UInt8Dtype | pd.UInt16Dtype | pd.UInt32Dtype | pd.UInt64Dtype | Literal["UInt8", "UInt16", "UInt32", "UInt64"] | type[np.ubyte] | Literal["B", "u1", "uint8", "ubyte"] | type[np.ushort] | Literal["H", "u2", "uint16", "ushort"] | type[np.uintc] | Literal["I", "u4", "uint32", "uintc"] | type[np.uint] | Literal["L", "u8", "uint", "ulong", "uint64"] | type[np.ulonglong] | Literal["Q", "ulonglong"] | type[np.uintp] | Literal["P", "uintp"] | Literal["uint8[pyarrow]", "uint16[pyarrow]", "uint32[pyarrow]", "uint64[pyarrow]"])
FloatDtypeArg: TypeAlias = (type[float] | Literal["float"] | pd.Float32Dtype | pd.Float64Dtype | Literal["Float32", "Float64"] | type[np.half] | Literal["e", "f2", "<f2", "float16", "half"] | type[np.single] | Literal["f", "f4", "float32", "single"] | type[np.double] | Literal["d", "f8", "float64", "double", "float_"] | type[np.longdouble] | Literal["g", "f16", "float128", "longdouble", "longfloat"] | Literal["float[pyarrow]", "double[pyarrow]", "float16[pyarrow]", "float32[pyarrow]", "float64[pyarrow]",])
ComplexDtypeArg: TypeAlias = (type[complex] | Literal["complex"] | type[np.csingle] | Literal["F", "c8", "complex64", "csingle", "singlecomplex"] | type[np.cdouble] | Literal["D", "c16", "complex128", "cdouble", "cfloat", "complex_"] | type[np.clongdouble] | Literal["G", "c32", "complex256", "clongdouble", "clongfloat", "longcomplex",])
TimedeltaDtypeArg: TypeAlias = Literal["timedelta64[Y]", "timedelta64[M]", "timedelta64[W]", "timedelta64[D]", "timedelta64[h]", "timedelta64[m]", "timedelta64[s]", "timedelta64[ms]", "timedelta64[us]", "timedelta64[μs]", "timedelta64[ns]", "timedelta64[ps]", "timedelta64[fs]", "timedelta64[as]", "m8[Y]", "m8[M]", "m8[W]", "m8[D]", "m8[h]", "m8[m]", "m8[s]", "m8[ms]", "m8[us]", "m8[μs]", "m8[ns]", "m8[ps]", "m8[fs]", "m8[as]", "<m8[Y]", "<m8[M]", "<m8[W]", "<m8[D]", "<m8[h]", "<m8[m]", "<m8[s]", "<m8[ms]", "<m8[us]", "<m8[μs]", "<m8[ns]", "<m8[ps]", "<m8[fs]", "<m8[as]", "duration[s][pyarrow]", "duration[ms][pyarrow]", "duration[us][pyarrow]", "duration[ns][pyarrow]",]
TimestampDtypeArg: TypeAlias = Literal["datetime64[Y]", "datetime64[M]", "datetime64[W]", "datetime64[D]", "datetime64[h]", "datetime64[m]", "datetime64[s]", "datetime64[ms]", "datetime64[us]", "datetime64[μs]", "datetime64[ns]", "datetime64[ps]", "datetime64[fs]", "datetime64[as]", "M8[Y]", "M8[M]", "M8[W]", "M8[D]", "M8[h]", "M8[m]", "M8[s]", "M8[ms]", "M8[us]", "M8[μs]", "M8[ns]", "M8[ps]", "M8[fs]", "M8[as]", "<M8[Y]", "<M8[M]", "<M8[W]", "<M8[D]", "<M8[h]", "<M8[m]", "<M8[s]", "<M8[ms]", "<M8[us]", "<M8[μs]", "<M8[ns]", "<M8[ps]", "<M8[fs]", "<M8[as]", "date32[pyarrow]", "date64[pyarrow]", "timestamp[s][pyarrow]", "timestamp[ms][pyarrow]", "timestamp[us][pyarrow]", "timestamp[ns][pyarrow]",]
StrDtypeArg: TypeAlias = (type[str] | Literal["str"] | pd.StringDtype | Literal["string"] | type[np.str_] | Literal["U", "str_", "str0", "unicode", "unicode_"] | Literal["string[pyarrow]"])
BytesDtypeArg: TypeAlias = (type[bytes] | Literal["bytes"] | type[np.bytes_] | Literal["S", "bytes_", "bytes0", "string_"] | Literal["binary[pyarrow]"])
CategoryDtypeArg: TypeAlias = CategoricalDtype | Literal["category"]
ObjectDtypeArg: TypeAlias = (type[object] | Literal["object"] | type[np.object_] | Literal["O"])
VoidDtypeArg: TypeAlias = (type[np.void] | Literal["V", "void", "void0"])
DtypeArg: TypeAlias = Dtype | Mapping[Hashable, Dtype]
DtypeObj: TypeAlias = np.dtype[np.generic] | ExtensionDtype
AstypeArg: TypeAlias = (BooleanDtypeArg | IntDtypeArg | UIntDtypeArg | StrDtypeArg | BytesDtypeArg | FloatDtypeArg | ComplexDtypeArg | TimedeltaDtypeArg | TimestampDtypeArg | CategoryDtypeArg | ObjectDtypeArg | VoidDtypeArg | DtypeObj)
ConvertersArg: TypeAlias = Mapping[Hashable, Callable[[Dtype], Dtype]]
ParseDatesArg: TypeAlias = (bool | list[Hashable] | list[list[Hashable]] | Mapping[HashableT, list[HashableT2]])
Label: TypeAlias = Hashable | None
Renamer: TypeAlias = Mapping[Any, Label] | Callable[[Any], Label]
T = TypeVar("T")
FuncType: TypeAlias = Callable[..., Any]
F = TypeVar("F", bound=FuncType)
TypeT = TypeVar("TypeT", bound=type)
ValueKeyFunc: TypeAlias = Callable[[Series], Series | AnyArrayLike] | None
IndexKeyFunc: TypeAlias = Callable[[Index], Index | AnyArrayLike] | None
AggFuncTypeBase: TypeAlias = Union[Callable, str, np.ufunc]
AggFuncTypeDictSeries: TypeAlias = Mapping[HashableT, AggFuncTypeBase]
AggFuncTypeDictFrame: TypeAlias = Mapping[HashableT, AggFuncTypeBase | list[AggFuncTypeBase]]
AggFuncTypeSeriesToFrame: TypeAlias = list[AggFuncTypeBase] | AggFuncTypeDictSeries
AggFuncTypeFrame: TypeAlias = (AggFuncTypeBase | list[AggFuncTypeBase] | AggFuncTypeDictFrame)
AggFuncTypeDict: TypeAlias = AggFuncTypeDictSeries | AggFuncTypeDictFrame
AggFuncType: TypeAlias = AggFuncTypeBase | list[AggFuncTypeBase] | AggFuncTypeDict
AnyStr_co = TypeVar("AnyStr_co", str, bytes, covariant=True)
AnyStr_contra = TypeVar("AnyStr_contra", str, bytes, contravariant=True)
class BaseBuffer(Protocol):
    @property
    def mode(self) -> str:
        ...
    
    def seek(self, offset: int, whence: int = ..., /) -> int:
        ...
    
    def seekable(self) -> bool:
        ...
    
    def tell(self) -> int:
        ...
    


class ReadBuffer(BaseBuffer, Protocol[AnyStr_co]):
    def read(self, n: int = ..., /) -> AnyStr_co:
        ...
    


class WriteBuffer(BaseBuffer, Protocol[AnyStr_contra]):
    def write(self, b: AnyStr_contra, /) -> Any:
        ...
    
    def flush(self) -> Any:
        ...
    


class ReadPickleBuffer(ReadBuffer[bytes], Protocol):
    def readline(self) -> bytes:
        ...
    


class WriteExcelBuffer(WriteBuffer[bytes], Protocol):
    def truncate(self, size: int | None = ..., /) -> int:
        ...
    


class ReadCsvBuffer(ReadBuffer[AnyStr_co], Protocol):
    def __iter__(self) -> Iterator[AnyStr_co]:
        ...
    
    def fileno(self) -> int:
        ...
    
    def readline(self) -> AnyStr_co:
        ...
    
    @property
    def closed(self) -> bool:
        ...
    


FilePath: TypeAlias = str | PathLike[str]
StorageOptions: TypeAlias = dict[str, Any] | None
CompressionDict: TypeAlias = dict[str, Any]
CompressionOptions: TypeAlias = (None | Literal["infer", "gzip", "bz2", "zip", "xz", "zstd", "tar"] | CompressionDict)
FormattersType: TypeAlias = (list[Callable] | tuple[Callable, ...] | Mapping[str | int, Callable])
FloatFormatType: TypeAlias = str | Callable[[float], str] | EngFormatter
ColspaceArgType: TypeAlias = (str | int | Sequence[int | str] | Mapping[Hashable, str | int])
FillnaOptions: TypeAlias = Literal["backfill", "bfill", "ffill", "pad"]
InterpolateOptions: TypeAlias = Literal["linear", "time", "index", "values", "nearest", "zero", "slinear", "quadratic", "cubic", "barycentric", "polynomial", "krogh", "piecewise_polynomial", "spline", "pchip", "akima", "cubicspline", "from_derivatives",]
ScalarIndexer: TypeAlias = int | np.integer
SequenceIndexer: TypeAlias = slice | list[int] | np.ndarray
PositionalIndexer: TypeAlias = ScalarIndexer | SequenceIndexer
PositionalIndexerTuple: TypeAlias = tuple[PositionalIndexer, PositionalIndexer]
TakeIndexer: TypeAlias = Sequence[int] | Sequence[np.integer] | npt.NDArray[np.integer]
IgnoreRaise: TypeAlias = Literal["ignore", "raise"]
WindowingRankType: TypeAlias = Literal["average", "min", "max"]
CSVEngine: TypeAlias = Literal["c", "python", "pyarrow", "python-fwf"]
JSONEngine: TypeAlias = Literal["ujson", "pyarrow"]
XMLParsers: TypeAlias = Literal["lxml", "etree"]
HTMLFlavors: TypeAlias = Literal["lxml", "html5lib", "bs4"]
IntervalT = TypeVar("IntervalT", bound=Interval)
IntervalLeftRight: TypeAlias = Literal["left", "right"]
IntervalClosedType: TypeAlias = IntervalLeftRight | Literal["both", "neither"]
RaiseCoerce: TypeAlias = Literal["raise", "coerce"]
DateTimeErrorChoices: TypeAlias = RaiseCoerce
SortKind: TypeAlias = Literal["quicksort", "mergesort", "heapsort", "stable"]
NaPosition: TypeAlias = Literal["first", "last"]
NsmallestNlargestKeep: TypeAlias = Literal["first", "last", "all"]
QuantileInterpolation: TypeAlias = Literal["linear", "lower", "higher", "midpoint", "nearest"]
AnyAll: TypeAlias = Literal["any", "all"]
JoinHow: TypeAlias = Literal["left", "right", "outer", "inner"]
MergeHow: TypeAlias = JoinHow | Literal["cross", "left_anti", "right_anti"]
ValidationOptions: TypeAlias = Literal["one_to_one", "1:1", "one_to_many", "1:m", "many_to_one", "m:1", "many_to_many", "m:m",]
MergeValidate: TypeAlias = ValidationOptions
JoinValidate: TypeAlias = ValidationOptions
ReindexMethod: TypeAlias = FillnaOptions | Literal["nearest"]
TimeGrouperOrigin: TypeAlias = (Timestamp | Literal["epoch", "start", "start_day", "end", "end_day"])
TimeAmbiguous: TypeAlias = Literal["infer", "NaT", "raise"] | npt.NDArray[np.bool_]
TimeNonexistent: TypeAlias = (Literal["shift_forward", "shift_backward", "NaT", "raise"] | Timedelta | datetime.timedelta)
DropKeep: TypeAlias = Literal["first", "last", False]
CorrelationMethod: TypeAlias = (Literal["pearson", "kendall", "spearman"] | Callable[[np.ndarray, np.ndarray], float])
AlignJoin: TypeAlias = Literal["outer", "inner", "left", "right"]
DtypeBackend: TypeAlias = Literal["pyarrow", "numpy_nullable"]
TimeUnit: TypeAlias = Literal["s", "ms", "us", "ns"]
OpenFileErrors: TypeAlias = Literal["strict", "ignore", "replace", "surrogateescape", "xmlcharrefreplace", "backslashreplace", "namereplace",]
UpdateJoin: TypeAlias = Literal["left"]
FromDictOrient: TypeAlias = Literal["columns", "index", "tight"]
ToStataByteorder: TypeAlias = Literal[">", "<", "little", "big"]
ExcelWriterIfSheetExists: TypeAlias = Literal["error", "new", "replace", "overlay"]
ExcelWriterMergeCells: TypeAlias = bool | Literal["columns"]
UsecolsArgType: TypeAlias = (SequenceNotStr[Hashable] | range | AnyArrayLike | Callable[[HashableT], bool] | None)
SliceType: TypeAlias = Hashable | None
num: TypeAlias = complex
DtypeNp = TypeVar("DtypeNp", bound=np.dtype[np.generic])
KeysArgType: TypeAlias = Any
ListLikeT = TypeVar("ListLikeT", bound=ListLike)
ListLikeExceptSeriesAndStr: TypeAlias = (MutableSequence[Any] | np.ndarray | tuple[Any, ...] | Index)
ListLikeU: TypeAlias = Sequence | np.ndarray | Series | Index
ListLikeHashable: TypeAlias = (MutableSequence[HashableT] | np.ndarray | tuple[HashableT, ...] | range)
StrLike: TypeAlias = str | np.str_
ScalarT = TypeVar("ScalarT", bound=Scalar)
np_ndarray_int64: TypeAlias = npt.NDArray[np.int64]
np_ndarray_int: TypeAlias = npt.NDArray[np.signedinteger]
np_ndarray_anyint: TypeAlias = npt.NDArray[np.integer]
np_ndarray_float: TypeAlias = npt.NDArray[np.floating]
np_ndarray_complex: TypeAlias = npt.NDArray[np.complexfloating]
np_ndarray_bool: TypeAlias = npt.NDArray[np.bool_]
np_ndarray_str: TypeAlias = npt.NDArray[np.str_]
IndexType: TypeAlias = slice | np_ndarray_anyint | Index | list[int] | Series[int]
MaskType: TypeAlias = Series[bool] | np_ndarray_bool | list[bool]
SeriesDType: TypeAlias = (str | bytes | datetime.date | datetime.time | bool | int | float | complex | Dtype | datetime.datetime | datetime.timedelta | Period | Interval | CategoricalDtype | BaseOffset | list[str])
S1 = TypeVar("S1", bound=SeriesDType, default=Any)
S2 = TypeVar("S2", bound=SeriesDType)
S3 = TypeVar("S3", bound=SeriesDType)
IndexingInt: TypeAlias = (int | np.int_ | np.integer | np.unsignedinteger | np.signedinteger | np.int8)
AxesData: TypeAlias = Mapping[S3, Any] | Axes | KeysView
Function: TypeAlias = np.ufunc | Callable[..., Any]
_HashableTa = TypeVar("_HashableTa", bound=Hashable)
ByT = TypeVar("ByT", bound=str | bytes | datetime.date | datetime.datetime | datetime.timedelta | np.datetime64 | np.timedelta64 | bool | int | float | complex | Scalar | Period | Interval[int | float | Timestamp | Timedelta] | tuple)
SeriesByT = TypeVar("SeriesByT", bound=str | bytes | datetime.date | bool | int | float | complex | datetime.datetime | datetime.timedelta | Period | Interval[int | float | Timestamp | Timedelta])
GroupByObjectNonScalar: TypeAlias = (tuple | list[_HashableTa] | Function | list[Function] | list[Series] | np.ndarray | list[np.ndarray] | Mapping[Label, Any] | list[Mapping[Label, Any]] | list[Index] | Grouper | list[Grouper])
GroupByObject: TypeAlias = Scalar | Index | GroupByObjectNonScalar | Series
StataDateFormat: TypeAlias = Literal["tc", "%tc", "td", "%td", "tw", "%tw", "tm", "%tm", "tq", "%tq", "th", "%th", "ty", "%ty",]
ReplaceValue: TypeAlias = (Scalar | Pattern | NAType | Sequence[Scalar | Pattern] | Mapping[HashableT, ScalarT] | Series | None)
JsonFrameOrient: TypeAlias = Literal["split", "records", "index", "columns", "values", "table"]
JsonSeriesOrient: TypeAlias = Literal["split", "records", "index", "table"]
TimestampConvention: TypeAlias = Literal["start", "end", "s", "e"]
CSVQuotingCompat: TypeAlias = Literal[0, 1, 2, 3]
if sys.version_info >= (3, 12):
    ...
else:
    CSVQuoting: TypeAlias = CSVQuotingCompat
HDFCompLib: TypeAlias = Literal["zlib", "lzo", "bzip2", "blosc"]
ParquetEngine: TypeAlias = Literal["auto", "pyarrow", "fastparquet"]
FileWriteMode: TypeAlias = Literal["a", "w", "x", "at", "wt", "xt", "ab", "wb", "xb", "w+", "w+b", "a+", "a+b"]
WindowingEngine: TypeAlias = Literal["cython", "numba"] | None
class _WindowingNumbaKwargs(TypedDict, total=False):
    nopython: bool
    nogil: bool
    parallel: bool
    ...


WindowingEngineKwargs: TypeAlias = _WindowingNumbaKwargs | None
class StyleExportDict(TypedDict, total=False):
    apply: Any
    table_attributes: Any
    table_styles: Any
    hide_index: bool
    hide_columns: bool
    hide_index_names: bool
    hide_column_names: bool
    css: dict[str, str | int]
    ...


CalculationMethod: TypeAlias = Literal["single", "table"]
ExcelReadEngine: TypeAlias = Literal["xlrd", "openpyxl", "odf", "pyxlsb", "calamine"]
ExcelWriteEngine: TypeAlias = Literal["openpyxl", "odf", "xlsxwriter"]
TimeZones: TypeAlias = str | tzinfo | None | int
IntoColumn: TypeAlias = (AnyArrayLike | Scalar | Callable[[DataFrame], AnyArrayLike | Scalar | Sequence[Scalar] | range] | Sequence[Scalar] | range | None)
DatetimeLike: TypeAlias = datetime.datetime | np.datetime64 | Timestamp
DateAndDatetimeLike: TypeAlias = datetime.date | DatetimeLike
DatetimeDictArg: TypeAlias = (Sequence[int] | Sequence[float] | list[str] | tuple[Scalar, ...] | AnyArrayLike)
DictConvertible: TypeAlias = FulldatetimeDict | DataFrame
Incomplete: TypeAlias = Any
__all__ = ["npt", "type_t"]
